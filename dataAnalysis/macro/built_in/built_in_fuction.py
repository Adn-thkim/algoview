# -*- coding: utf-8 -*-
"""알고리즘 오픈소스 프로젝트.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yC-krKwPSpjTtqMje53ekxXkvCTkv9Ce
"""

import re
from collections import Counter

def get_built_in_func_cnt(code_data: str, language: str) -> dict:
    '''
    file_data의 code 문자열 데이터를 받아 Built_in_func 사용 횟수를 dict로 반환해줍니다.

    Args:
        code_data (str): 코드 문자열 데이터
        language (str): 언어 데이터

    Returns:
        built_in_func_cnt_data (dict): 사용된 빌트인 함수 사용 횟수 데이터. 각 빌트인 함수가 횟수와 함께 포함된 딕셔너리
    '''

    # python일때
    if language == "python":
        with open('/content/built_in_python.txt', 'r') as file:  # 내장 함수 목록이 저장된 파일의 경로 입력
            built_in_list = []
            section_start = False
            current_section = ""
            for line in file:
                if line.startswith('['):
                    # 섹션 시작을 표시하고 현재 섹션을 설정합니다.
                    section_start = True
                    current_section = line.strip()
                    continue
                if section_start and line.strip():
                    # 빈 줄이 아니면 내장 함수를 리스트에 추가합니다.
                    built_in_list.append(line.strip())

        # 정규 표현식에 사용할 함수 목록 문자열을 생성합니다.
        func_list_str = '|'.join(built_in_list)

        # 함수 호출 형태의 패턴을 찾기 위한 정규 표현식 패턴을 컴파일합니다.
        p = re.compile(f'\\b({func_list_str})\\s*\\(')

        # 메소드 함수를 추가합니다.
        if current_section == "[리스트 메소드 함수]" or current_section == "[딕셔너리 메소드 함수]" or current_section == "[문자열 메소드 함수]":
            # 메소드 함수의 패턴을 찾기 위한 정규 표현식 패턴을 컴파일합니다.
            p = re.compile(f'\\b({func_list_str})\\b')
        
        # 코드 데이터에서 정규 표현식 패턴에 일치하는 함수를 찾아 개수를 세고, 딕셔너리 형태로 반환합니다.
        built_in_func_cnt_data = dict(Counter(p.findall(code_data)))
        return built_in_func_cnt_data

    # javascript일때
    elif language == "javascript":
        with open('/content/built_in_javascript.txt', 'r') as file:  # 내장 함수 목록이 저장된 파일의 경로 입력
            built_in_list = []
            section_start = False
            current_section = ""
            for line in file:
                if line.startswith('['):
                    # 섹션 시작을 표시하고 현재 섹션을 설정합니다.
                    section_start = True
                    current_section = line.strip()
                    continue
                if section_start and line.strip():
                    # 빈 줄이 아니면 내장 함수를 리스트에 추가합니다.
                    # 줄을 '.'으로 분할합니다.
                    line_parts = line.strip().split('.')
                    # 마지막 단어를 추출합니다.
                    last_word = line_parts[-1]
                    # 마지막 단어를 내장 함수 리스트에 추가합니다.
                    built_in_list.append(last_word)

        # 정규 표현식에 사용할 함수 목록 문자열을 생성합니다.
        func_list_str = '|'.join(built_in_list)

        # 함수명 패턴을 찾기 위한 정규 표현식 패턴을 컴파일합니다.
        p = re.compile(f'\\b({func_list_str})\\b')

        # 코드 데이터에서 정규 표현식 패턴에 일치하는 함수를 찾아 개수를 세고, 딕셔너리 형태로 반환합니다.
        built_in_func_cnt_data = dict(Counter(p.findall(code_data)))
        return built_in_func_cnt_data

    else:
        raise ValueError("Invalid language specified.")

javascript_code = '''
function greet(name) {
    console.log("Hello, " + name);
}

function calculateSquare(num) {
    return num ** 2;
}

function main() {
    greet("John");
    var result = calculateSquare(5);
    console.log(result);
}

var myArray = [1, 2, 3];
myArray.push(4);
myArray.sort();
'''

built_in_func_cnt_data_javascript = get_built_in_func_cnt(javascript_code, "javascript")
print(built_in_func_cnt_data_javascript)

python_code = '''
def greet(name):
    print("Hello, " + name)

def calculate_square(num):
    return num ** 2

def main():
    greet("John")
    result = calculate_square(5)
    print(result)

my_list = [1, 2, 3]
my_list.append(4)
my_list.sort()
'''
built_in_func_cnt_data_python = get_built_in_func_cnt(python_code, "python")
print(built_in_func_cnt_data_python)
